<!--
%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{qq}
-->

# Quasiquotation in the `vadr` package

The `vadr` package includes a facility called _quasiquotation._ This is a technique that helps you build expressions and other data structures by template substitution.

Quasiquotation is often described is as as a tool for writing code that writes code (or "metaprogramming.") But it's also useful in data processing. In a way quasiquotation is like an inverse of destructuring bind (which `vadr` also provides, in the `bind` operation.) While destructuring bind extracts data from a structure by writing an code that mirrors the structure, quasiquotation lets you populate data _into_ a structure by writing code that mirrors that structure.

Base R has a very limited implementation of quasiquotation in the function `bquote`. The functions included in the `vadr` package are much more flexible, and should run faster (after they do initial expansion.)

Quasiquotation is a language feature that descends from Lisp, and any language that claims to descend from the Lisp family ought to have a working implementaiton. If this vignette doesn't convince you it's a good thing to have, you could read Alan Bawden's essay [Quasiquotation in Lisp][1]. for some more background
[1]: http://repository.readscheme.org/ftp/papers/pepm99/bawden.pdf

## Examples of quasiquotation

### Generating sophisticated plot labels

The `expression` function is used to produce mathematical formatting and symbol characters in plots, as in the x-axis tick labels here:

```{r, include=FALSE, cache=FALSE}
opts_chunk$set(cache=TRUE, dev="svg", fig.width=5, fig.height=3)
options(width=60)
```

```{r, plot=TRUE, height.out=1}
par(las = 1, cex = 1, mai=c(1, 0, 0, 0))
curve(sin(x)/x, -3*pi, 3*pi, axes = FALSE, ylab="")
par(cex=0.7)
axis(1, at=seq(-5, 5, 2)*pi/2,
     labels=expression(over(-5, 2)*pi, over(-3,2)*pi,
                       over(-1, 2)*pi, over(3,2)*pi,
                       over(3,2)*pi, over(5,2)*pi),
     padj=0.5)
```

`expression` is useful for one-shot annotations but is hard to generalize. It was kind of laborious to type in all those tick labels. If you have a lot of trigonometric functions to plot you'll quickly tire of labeling ticks this way. What if we had a function to generate the that of expressions?

We might naively try something like the below.

```{r}
numerator <- seq(-5, 5, 2)
denominator <- 2
symbol <- quote(pi)
at <- numerator * pi / denominator
labels <- mapply(numerator, FUN = function(num) {
  expression(over(num, denominator) * symbol)
})
labels
```

Unfortunately doesn't work because "expression" doesn't evaluate its operand. We got a bunch of this:

```{r, echo=FALSE, fig.height=1.2}
par(mai=c(1,0,0,0))
plot(c(-3*pi,3*pi), c(0,1), type="n", axes=FALSE, xlab="", ylab="")
axis(1, at=at, labels=labels, padj=0.5)
```

The thing is that `expression` will _quote_ an expression as we wrote it literally, but what we need is to _construct_ an expression out of bits of data we have. Facing this difficulty, many S users resort to something rebarbative using `parse` and `parse`:

```{r}
labels <- parse(text=paste0(
    "over(", numerator , ", ", denominator, ") * ", symbol))
labels
```

This works for simple cases but there are some obvious problems with this approach. First, because the code is manipulated in strings, it's possible to create syntax errors (on top of just semantic errors.) Mainly, it quickly becomes hard to read. Parentheses and commas belonging to two logically distinct sets of code interleave themselves together via quotation marks, making it hard to see if either expression is well formed.

A more principled way to build expressions is to use "computing on the language" to build expression objects out of data, like the following.

```{r}
labels <- as.expression(sapply(numerator, function(num) {
  call("*", call("over", num, denominator), symbol)
  }))
labels
```

This uses R's ability to represent code as data and vice versa, which is one of the strengths of the language. An expression like `a*b` is really just a special type of list;
`quote( a * b ) is really the same thing as `as.call( quote(*), quote(a), quote(b) )`. (Further, `quote(a)` is the same thing as `as.name("a")`.)

This avoids a round trip through the parser and the possibilty of forming unparseable strings, but I can't say that this version is any easier to read than the last.  Much of the resemblance between the expressions you want and the code you are writing is lost.

You can get a little closer using `substitute`:

```{r}
(labels <- sapply( numerator, function(num) {
  eval(substitute(
      expression( over(num, denominator) * symbol),
      list(num=num, denominator=denominator, symbol=symbol)))
}))
```

The first argument to `substitute` does mirror the deisred results better but I often find constructing the second argument be tedious -- here it's more than half of the call to `substitute` and doesn't say much. I also dislike the fact that you can't tell _what_ is getting substituted out without cross-referencing the expression to the named list. It's not apparent that `num` is being substituted while `over` is not, unless you cross-reference the expression against the list.

A further problem is that `substitute` is limited to only substituting for symbols, when there are more things in R's syntax that are beyond its reach. For example, 'substitute' doesn't touch function argument lists or names. This doesn't doesn't do what it looks like it wants to do:

```{r}
substitute( function(argname=default) list( output_name=argname ),
            list(argname=quote(X), default=quote(Y), output_name=quote(Z)))
```

(Yet another problem is that `substitute` has a dual, almost unrelated effect of extracting the unevaluated code from a function argument, so even if you are familiar with `substitute` in can be tricky to read code that uses it because you have to figure out which effect of `substitute` is being exploited.)

### Building expressions with quasiquote

What we'd like is a way to build expressions of the form `over(numerator, denominator) * symbol` that actually looks like that's what we're trying to make. That's what quasiquotation tries to do.

```{r}
library(vadr)
labels <- as.expression(lapply(numerator, function(num) {
  qq(
      over(.(num), .(denominator)) * .(symbol)
    )
}))
```

Here, `qq` acts like `quote,` doing nothing to its argument, except for sections delineated with `.()`, which are evaluated and their results pasted in. This comes close to the ideal where the structure of the desired output is mirrored by the code that produces it.

The places where code is being substituted in are visually delineated with the `.()` and we don't have to make reference to a parallel list of values while wirking out what this is going to do.

## Quasiquote improves over `bquote`

The above could be have been done using the base R function `bquote`, but `qq` has some extensions that make it much more flexible. Most importantly it implements _splicing_ when you use a marker with two dots, `..()`.

### Splicing

Splicing injects _several_ arguments into an expression marked with `..()`, where  `.()` injects just one. You might think of it as the difference between `c` and `list`.

```{r}
x <- c(1,2,3)
qq(list("normal:", .(x), "splicing:", ...(x)))
```

This is something you just can't do with `bquote` (and `substitute` only does splicing in a special case requiring you to get data into a `...` variable in an environment.)

*Exercise:* What explains the differences between 'data' and 'expr' here?

```R
data <- c(1,2,3)
dput(data)
expr <- quote(c(1, 2, 3))
dput(expr)
qq(list("data normal:", .(data), " data spliced:", ...(data)))
qq(list("expression normal:", .(expr), " expression spliced:", ...(expr)))
```

(Beware: R sometimes prints a vector or list in the same way that it prints a call _to_ `vector` or `list`, but these two cases have different structure.)

### Computed names

The other place where `qq` and friends improve over `bquote` is in the treatment of names. In R, unlike most Lisps, every argument to a call has a name attached. So a quasiquotation overator that fits R will have to do something about names. With `qq`, any argument name, string or variable name that looks like `".()"` will be parsed and have the evaluated results substituted in.

So, if you need to create a function that has a particular argument name:

```{r}
make_function_of <- function(argname) {
  qe( function( `.(argname)` ) {
    `.(argname)` + 12
  })
}

make_function_of("X")
```

Finally, there are two convenience functions that combine quasiquotation with `mapply`, called `qqply` and `qeply`, which are convenient wen you want to build a list of different substituted expressions, For example, our list of labels could be further simplified to:

```r
as.expression(
    qqply(
        over( .(num), .(denom) ) * .(symbol)
    )(num=numerator)
)
```

### Example: `mkchain`

`mkchain` is a tool in the `vadr` package that builds a function by "chaining" the output of one call into the input of the next. (`chain` is like the [`->` macro][clojure] in Clojure and the [`|>` operator][elixir] in Elixir.)

[clojure]:
[elixir]:

For example, say you wanted to know which baseball players have skipped a season of play.

mkchain(ddply("", sort(year)), subset(count > 25))

Implementing `mkchain` is a good example of code that writes code. Here we want  `mkchain(foo, bar(5), baz(6,X))` to greate a function that looks like

```r
function(X) {
  X <- foo(X)
  X <- bar(X, 5)
  X <- baz(X, 6)
}
```

That is, we want to treat X like a possibly [null subject][null], taken to be implicit if it is not given explicitly. `mkchain` creates the skeleton of the function using `qq`:

[null]: http://en.wikipedia.org/wiki/Null-subject_language

```{r}
mkchain <- macro(function(...) {
  qq(
      function(X) {
        ..( qqply( X <- .(chain_transform(arg)) )(arg=list(...)) )
        X
      }
  )
})
```
The outer call ot `qq` gives the skeleton of the function, while the inner call to `qqply` puts together the assignment statements. It calls out to `chain_step` which puts an `X` in if it is needed:

```{r}
chain_step <- function(expr) {
  if (is.call(expr)) {
    if ("X" %in% all.names(expr)) {
      #"call(Y, X)" means itself
      expr
    } else {
      #"call(Y)" means "call(X,Y)"
      qq( .(expr[[1]])(X, ...(expr[-1])) )
    }
  } else {
    #`symbol` means "symbol(X)"
    qq( .(expr)(X) )
  }
}
```

When called,`'mkchain` constructs a whole new function:

```
mkchain(foo, bar(5), baz(6, X), sum)
```

### `qq` is fast

Despite having much added functionality over `bquote`, `qq` is two or three times faster over repeated calls. This is because qq itself operates as a macro. The first time you call `qq`, it performs the lexical analysis of finding all the `.()` calls, parsing them and determining how to splice them in, but instead of directly substituting, `qq` compiles a new function just for that particuler substitution. When code comes to the same call to `bquote` again, that saved function is retrieved and executed quickly.

If you are curious to see what the compiled function looks like, `vadr:::qq_internal` is the hook into `qq`'s compiler.

```{r}
expr <- vadr:::qq_internal(
    quote( over(.(num), .(denominator)) * .(symbol) ) )
print(expr)
num <- 5
print(eval(expr))
```

Note that the compiled code uses literal values rather than calls to "list" whenever it can. So it may not produce code that looks like it works. Here `list(over) is actually a literal list containing `over`, rather than a call to `list` with the argument `over`; the former is not evaluated while the latter is. Unfortiunately R's printer does not distingussh these cases.

Because it can remember and skip over the lexical analysis it did the first time, `qq` is often two or three times faster than `bquote`.

The construction of the unquoter does take a bit of time on the first run-through, but the compiled form is faster than `bquote`.
